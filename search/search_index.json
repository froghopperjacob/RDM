{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RDM \u00b6 This is the main documentation area for RDM. RDM is a small and light weight dependency manager that is setup like NPM. The documentation is always a work in progress. If you find any issues with the documentation or RDM, please make an issue on RDM's issue tracker !","title":"Home"},{"location":"#rdm","text":"This is the main documentation area for RDM. RDM is a small and light weight dependency manager that is setup like NPM. The documentation is always a work in progress. If you find any issues with the documentation or RDM, please make an issue on RDM's issue tracker !","title":"RDM"},{"location":"getting-started/","text":"Getting Started \u00b6 Installing RDM \u00b6 Installing through Roblox Packages \u00b6 Head to RDM Package Add to inventory Go to toolbox and head to My Packages Add RDM - Roblox Dependency Manager to your wanted location Installing through the command bar \u00b6 Todo This hasn't been created yet and is currently in the TODO list. Feel free to start developing this. Installing through the Plugin \u00b6 Todo This hasn't been created yet and is currently in the TODO list. Feel free to start developing this. Installing Packages \u00b6","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installing-rdm","text":"","title":"Installing RDM"},{"location":"getting-started/#installing-through-roblox-packages","text":"Head to RDM Package Add to inventory Go to toolbox and head to My Packages Add RDM - Roblox Dependency Manager to your wanted location","title":"Installing through Roblox Packages"},{"location":"getting-started/#installing-through-the-command-bar","text":"Todo This hasn't been created yet and is currently in the TODO list. Feel free to start developing this.","title":"Installing through the command bar"},{"location":"getting-started/#installing-through-the-plugin","text":"Todo This hasn't been created yet and is currently in the TODO list. Feel free to start developing this.","title":"Installing through the Plugin"},{"location":"getting-started/#installing-packages","text":"","title":"Installing Packages"},{"location":"rdm-modules/eventhandler/","text":"String Module \u00b6 API Classes \u00b6 EventHandler \u00b6 EventHandler.Connect \u00b6 EventHandler . Connect ( eventName , function ) -> Event This creates a new event and connects a function to that event. EventHandler:Emit \u00b6 EventHandler : Emit ( eventName , ...) -> Void This calls every function associated with that eventName with the given arguements. Note You have to use the : format instead of the . format for this function. This is because it would be to complicated to move all arguemnts down a variable EventHandler.Register \u00b6 EventHandler . Register ( eventName ) -> Event This creates a new standalone event. This is useful if you want to return a event that someone can connect to. Event \u00b6 Event:Emit \u00b6 Event : Emit (...) -> Void Calls every function associated with the parent's Event. Note You have to use the : format instead of the . format for this function. This is because it would be to complicated to move all arguemnts down a variable Event.Disconnect \u00b6 Event . Disconnect () -> Void Completly kills the entire event and all child functions. Event.Connect \u00b6 Event . Connect ( function { ... }) -> Event Adds a new function to the parent Event. This returns a Event so that you can dazy-chain Connects if you wanted to. Examples \u00b6 local RDMF = game : GetService ( \"ServerScriptService\" ): WaitForChild ( \"RDM\" ) local RDM = require ( RDMF : WaitForChild ( \"MainModule\" ))( script ) local EventHandler = RDM : Import ( \"EventHandler\" ) local Remotes = game : GetService ( \"ReplicatedStorage\" ) local remoteEvent = Remotes : WaitForChild ( \"Event\" ) remoteEvent . OnClientEvent : Connect ( function ( command , ...) EventHandler : Emit ( command , ...) end ) EventHandler : Connect ( \"Instance\" , function ( instanceClass , properties ) local newClass = Instance . new ( instanceClass ) for key , value in pairs ( properties ) do newClass [ key ] = value end end )","title":"Event Handler"},{"location":"rdm-modules/eventhandler/#string-module","text":"","title":"String Module"},{"location":"rdm-modules/eventhandler/#api-classes","text":"","title":"API Classes"},{"location":"rdm-modules/eventhandler/#eventhandler","text":"","title":"EventHandler"},{"location":"rdm-modules/eventhandler/#eventhandlerconnect","text":"EventHandler . Connect ( eventName , function ) -> Event This creates a new event and connects a function to that event.","title":"EventHandler.Connect"},{"location":"rdm-modules/eventhandler/#eventhandleremit","text":"EventHandler : Emit ( eventName , ...) -> Void This calls every function associated with that eventName with the given arguements. Note You have to use the : format instead of the . format for this function. This is because it would be to complicated to move all arguemnts down a variable","title":"EventHandler:Emit"},{"location":"rdm-modules/eventhandler/#eventhandlerregister","text":"EventHandler . Register ( eventName ) -> Event This creates a new standalone event. This is useful if you want to return a event that someone can connect to.","title":"EventHandler.Register"},{"location":"rdm-modules/eventhandler/#event","text":"","title":"Event"},{"location":"rdm-modules/eventhandler/#eventemit","text":"Event : Emit (...) -> Void Calls every function associated with the parent's Event. Note You have to use the : format instead of the . format for this function. This is because it would be to complicated to move all arguemnts down a variable","title":"Event:Emit"},{"location":"rdm-modules/eventhandler/#eventdisconnect","text":"Event . Disconnect () -> Void Completly kills the entire event and all child functions.","title":"Event.Disconnect"},{"location":"rdm-modules/eventhandler/#eventconnect","text":"Event . Connect ( function { ... }) -> Event Adds a new function to the parent Event. This returns a Event so that you can dazy-chain Connects if you wanted to.","title":"Event.Connect"},{"location":"rdm-modules/eventhandler/#examples","text":"local RDMF = game : GetService ( \"ServerScriptService\" ): WaitForChild ( \"RDM\" ) local RDM = require ( RDMF : WaitForChild ( \"MainModule\" ))( script ) local EventHandler = RDM : Import ( \"EventHandler\" ) local Remotes = game : GetService ( \"ReplicatedStorage\" ) local remoteEvent = Remotes : WaitForChild ( \"Event\" ) remoteEvent . OnClientEvent : Connect ( function ( command , ...) EventHandler : Emit ( command , ...) end ) EventHandler : Connect ( \"Instance\" , function ( instanceClass , properties ) local newClass = Instance . new ( instanceClass ) for key , value in pairs ( properties ) do newClass [ key ] = value end end )","title":"Examples"},{"location":"rdm-modules/promises/","text":"String Module \u00b6 API Classes \u00b6 Promise \u00b6 Promise.New \u00b6 Promise . New ( function { resolve , reject }) -> Promiseables The given function is called with a function resolve and a function reject . The function is also called in a coroutine to allow error catching and to not yield the thread. Promiseables \u00b6 Promiseable.after \u00b6 Promiseable . after ( function { ... }) -> Promiseables When the main function resolve is called the arguments are passed down to the after function. You can return something in the after function for it to be dazy-chained to another after. Promiseable.finally \u00b6 Promiseable . finally ( function { ... }) -> Void The resolves and rejects are handed down the finally function. Promiseable.catch \u00b6 Promiseable . catch ([ string ], function { ... }) -> Limited Promiseables If there isn't the given string and there isn't another dazy-chained catch with that same string then this function is called. The first argument, string , is checked against the first rejected argument. A complete and catch is returned from .catch. Promiseable.complete \u00b6 Promiseable . complete () -> Void Tells the promiseable while loop that your done daizy-chaining afters. Warning If you are ever using a .after then you have to have a .complete() at the end. This is so that we don't have a constant while thread open and hogging system resources. Examples \u00b6 local RDMF = game : GetService ( \"ServerScriptService\" ): WaitForChild ( \"RDM\" ) local RDM = require ( RDMF : WaitForChild ( \"MainModule\" ))( script ) local Players = game : GetService ( \"Players\" ) local HttpService = game : GetService ( \"HttpService\" ) local Promise = RDM : Import ( \"Promise\" ) local baseUrl = \"https://example.com/\" local function getData ( player ) return Promise : New ( function ( resolve , reject ) local response = HttpService : RequestAsync ({ [ \"Url\" ] = string.format ( baseUrl .. \"/users/%d\" , player . UserId ), [ \"Method\" ] = \"GET\" }) if ( response [ \"Success\" ]) then resolve ( response [ \"Body\" ]) else reject ( response [ \"StatusCode\" ], response [ \"StatusMessage\" ]) end end ) end Players . PlayerAdded : Connect ( function ( player ) getData ( player ): after ( function ( body ) return HttpService : JSONDecode ( body ) end ): after ( function ( playerData ) if ( playerData [ \"Banned\" ]) then player : Kick ( playerData [ \"BanMessage\" ]) end end ): catch ( function ( statusCode , message ) error ( \"Unexpected error: \" .. statusCode .. \" | \" .. message ) end ): complete () end ) Note This doesn't work as https://example.com/ doesn't host roblox users, but you could make this work.","title":"Promises"},{"location":"rdm-modules/promises/#string-module","text":"","title":"String Module"},{"location":"rdm-modules/promises/#api-classes","text":"","title":"API Classes"},{"location":"rdm-modules/promises/#promise","text":"","title":"Promise"},{"location":"rdm-modules/promises/#promisenew","text":"Promise . New ( function { resolve , reject }) -> Promiseables The given function is called with a function resolve and a function reject . The function is also called in a coroutine to allow error catching and to not yield the thread.","title":"Promise.New"},{"location":"rdm-modules/promises/#promiseables","text":"","title":"Promiseables"},{"location":"rdm-modules/promises/#promiseableafter","text":"Promiseable . after ( function { ... }) -> Promiseables When the main function resolve is called the arguments are passed down to the after function. You can return something in the after function for it to be dazy-chained to another after.","title":"Promiseable.after"},{"location":"rdm-modules/promises/#promiseablefinally","text":"Promiseable . finally ( function { ... }) -> Void The resolves and rejects are handed down the finally function.","title":"Promiseable.finally"},{"location":"rdm-modules/promises/#promiseablecatch","text":"Promiseable . catch ([ string ], function { ... }) -> Limited Promiseables If there isn't the given string and there isn't another dazy-chained catch with that same string then this function is called. The first argument, string , is checked against the first rejected argument. A complete and catch is returned from .catch.","title":"Promiseable.catch"},{"location":"rdm-modules/promises/#promiseablecomplete","text":"Promiseable . complete () -> Void Tells the promiseable while loop that your done daizy-chaining afters. Warning If you are ever using a .after then you have to have a .complete() at the end. This is so that we don't have a constant while thread open and hogging system resources.","title":"Promiseable.complete"},{"location":"rdm-modules/promises/#examples","text":"local RDMF = game : GetService ( \"ServerScriptService\" ): WaitForChild ( \"RDM\" ) local RDM = require ( RDMF : WaitForChild ( \"MainModule\" ))( script ) local Players = game : GetService ( \"Players\" ) local HttpService = game : GetService ( \"HttpService\" ) local Promise = RDM : Import ( \"Promise\" ) local baseUrl = \"https://example.com/\" local function getData ( player ) return Promise : New ( function ( resolve , reject ) local response = HttpService : RequestAsync ({ [ \"Url\" ] = string.format ( baseUrl .. \"/users/%d\" , player . UserId ), [ \"Method\" ] = \"GET\" }) if ( response [ \"Success\" ]) then resolve ( response [ \"Body\" ]) else reject ( response [ \"StatusCode\" ], response [ \"StatusMessage\" ]) end end ) end Players . PlayerAdded : Connect ( function ( player ) getData ( player ): after ( function ( body ) return HttpService : JSONDecode ( body ) end ): after ( function ( playerData ) if ( playerData [ \"Banned\" ]) then player : Kick ( playerData [ \"BanMessage\" ]) end end ): catch ( function ( statusCode , message ) error ( \"Unexpected error: \" .. statusCode .. \" | \" .. message ) end ): complete () end ) Note This doesn't work as https://example.com/ doesn't host roblox users, but you could make this work.","title":"Examples"},{"location":"rdm-modules/string/","text":"String Module \u00b6 API Refrence \u00b6 String.Starts \u00b6 String . Starts ( string , startsWith ) -> Boolean Checks if the given string starts with the startsWith string. String.Ends \u00b6 String . Ends ( string , endsWith ) -> Boolean Checks if the given string ends with the endsWith string. String.Trim \u00b6 String . Trim ( string ) -> String Trims ending and starting whitespaces of the given string . String.Join \u00b6 String . Join ( fields , [ join ]) -> String Join Default: , Takes in a Array of characters ( fields ) with an optional join string. Each character is added to the string and the join . The last index doesn't have the join string added. String.Split \u00b6 String . Split ( string , [ seperator ]) -> Array Seperator Default: \"\" The function Split, splits the string with a optional seperator string into a array of characters String.Count \u00b6 String . Count ( string , counterString ) -> Number Counts the number of occurences from counterString in the string . String.IsLower \u00b6 String . IsLower ( string ) -> Boolean Checks if the entire string is all lowercase. String.IsUpper \u00b6 String . IsUpper ( string ) -> Boolean Checks if the entire string is all uppercase. String.EncodeHTML \u00b6 String . EncodeHTML ( string ) -> String Turns the given string into a HTML readable format. String.DecodeHTMLEntities \u00b6 String . DecodeHTMLEntities ( encodedHTML ) -> String Turns the given encodedHTML into a normal string. String.DecodeURL \u00b6 String . DecodeURL ( URLEncoded ) -> String Converts the UrlEncode string into a normal string. String.ToBoolean \u00b6 String . ToBoolean ( string ) -> Boolean Checks the given string to see if it equal to the following strings: true, on, 1, yes Examples \u00b6 local RDMF = game : GetService ( \"ServerScriptService\" ): WaitForChild ( \"RDM\" ) local RDM = require ( RDMF : WaitForChild ( \"MainModule\" ))( script ) local players = game : GetService ( \"Players\" ) local prefix = \"$\" local dem = \"/\" local stringUtil = RDM : Import ( \"String\" ) players . PlayerAdded : Connect ( function ( player ) player . Chatted : Connect ( function ( message ) if ( stringUtil : Starts ( message , prefix )) then local message = string.sub ( message , prefix : len ()) local arguments = stringUtil : Split ( message , dem ) if ( arguments [ 1 ] == \"kill\" ) then players [ arguments [ 2 ]]. Character : BreakJoints () end end end ) end ) Note Use a more modular command system if your actually going to implement this.","title":"String"},{"location":"rdm-modules/string/#string-module","text":"","title":"String Module"},{"location":"rdm-modules/string/#api-refrence","text":"","title":"API Refrence"},{"location":"rdm-modules/string/#stringstarts","text":"String . Starts ( string , startsWith ) -> Boolean Checks if the given string starts with the startsWith string.","title":"String.Starts"},{"location":"rdm-modules/string/#stringends","text":"String . Ends ( string , endsWith ) -> Boolean Checks if the given string ends with the endsWith string.","title":"String.Ends"},{"location":"rdm-modules/string/#stringtrim","text":"String . Trim ( string ) -> String Trims ending and starting whitespaces of the given string .","title":"String.Trim"},{"location":"rdm-modules/string/#stringjoin","text":"String . Join ( fields , [ join ]) -> String Join Default: , Takes in a Array of characters ( fields ) with an optional join string. Each character is added to the string and the join . The last index doesn't have the join string added.","title":"String.Join"},{"location":"rdm-modules/string/#stringsplit","text":"String . Split ( string , [ seperator ]) -> Array Seperator Default: \"\" The function Split, splits the string with a optional seperator string into a array of characters","title":"String.Split"},{"location":"rdm-modules/string/#stringcount","text":"String . Count ( string , counterString ) -> Number Counts the number of occurences from counterString in the string .","title":"String.Count"},{"location":"rdm-modules/string/#stringislower","text":"String . IsLower ( string ) -> Boolean Checks if the entire string is all lowercase.","title":"String.IsLower"},{"location":"rdm-modules/string/#stringisupper","text":"String . IsUpper ( string ) -> Boolean Checks if the entire string is all uppercase.","title":"String.IsUpper"},{"location":"rdm-modules/string/#stringencodehtml","text":"String . EncodeHTML ( string ) -> String Turns the given string into a HTML readable format.","title":"String.EncodeHTML"},{"location":"rdm-modules/string/#stringdecodehtmlentities","text":"String . DecodeHTMLEntities ( encodedHTML ) -> String Turns the given encodedHTML into a normal string.","title":"String.DecodeHTMLEntities"},{"location":"rdm-modules/string/#stringdecodeurl","text":"String . DecodeURL ( URLEncoded ) -> String Converts the UrlEncode string into a normal string.","title":"String.DecodeURL"},{"location":"rdm-modules/string/#stringtoboolean","text":"String . ToBoolean ( string ) -> Boolean Checks the given string to see if it equal to the following strings: true, on, 1, yes","title":"String.ToBoolean"},{"location":"rdm-modules/string/#examples","text":"local RDMF = game : GetService ( \"ServerScriptService\" ): WaitForChild ( \"RDM\" ) local RDM = require ( RDMF : WaitForChild ( \"MainModule\" ))( script ) local players = game : GetService ( \"Players\" ) local prefix = \"$\" local dem = \"/\" local stringUtil = RDM : Import ( \"String\" ) players . PlayerAdded : Connect ( function ( player ) player . Chatted : Connect ( function ( message ) if ( stringUtil : Starts ( message , prefix )) then local message = string.sub ( message , prefix : len ()) local arguments = stringUtil : Split ( message , dem ) if ( arguments [ 1 ] == \"kill\" ) then players [ arguments [ 2 ]]. Character : BreakJoints () end end end ) end ) Note Use a more modular command system if your actually going to implement this.","title":"Examples"}]}